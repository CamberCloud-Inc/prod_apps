import os
import sys
import argparse
import MDAnalysis as mda
import matplotlib.pyplot as plt
import imageio
import numpy as np
import pandas as pd
import matplotlib.gridspec as gridspec
from MDAnalysis.lib.distances import distance_array
import re

# --- Add argument parsing ---
parser = argparse.ArgumentParser(description="Visualize LAMMPS trajectory with force arrows.")
parser.add_argument('--left_force_duration', type=int, required=True,
                    help='Number of timesteps left force is applied (arrow shown)')
parser.add_argument('--left_velocity', type=float, required=True,
                    help='Velocity applied to left face (for arrow strength)')
args = parser.parse_args()
arrow_top_off_timestep = args.left_force_duration
left_velocity = args.left_velocity
base_arrow_length = 10
arrow_length = base_arrow_length * abs(left_velocity) * 1000  # scale as needed
# ---

base_path = os.getcwd()
u = mda.Universe(os.path.join(base_path, "trajectory.lammpstrj"), format="LAMMPSDUMP")

images = []
N = 10
arrow_width = 1
arrow_head = 4
decay = 5

positions = u.atoms.positions
distances = distance_array(positions, positions)
bond_pairs = [(i, j) for i in range(len(u.atoms)) for j in range(i+1, len(u.atoms)) if 1.2 <= distances[i, j] <= 1.8]
if bond_pairs:
    u.add_TopologyAttr('bonds', np.array(bond_pairs))

# Static limits for consistent plots
all_x = np.concatenate([ts.positions[:, 0] for ts in u.trajectory])
all_y = np.concatenate([ts.positions[:, 1] for ts in u.trajectory])
xlim = (all_x.min(), all_x.max())
ylim = (all_y.min(), all_y.max())

u.trajectory.rewind()

# --- Read temperature data from CSV file ---
def read_temperature_csv(filename):
    """Read temperature data from CSV file generated by LAMMPS."""
    try:
        temp_df = pd.read_csv(filename)
        print(f"[DEBUG] Read {len(temp_df)} temperature records from {filename}")
        print(f"[DEBUG] CSV columns: {temp_df.columns.tolist()}")
        print(f"[DEBUG] First 5 rows:\n{temp_df.head()}")
        return temp_df
    except FileNotFoundError:
        print(f"[DEBUG] Temperature CSV file {filename} not found")
        return None
    except Exception as e:
        print(f"[DEBUG] Error reading temperature CSV: {e}")
        return None

# Read temperature data from CSV
temp_df = read_temperature_csv('temperature.csv')

if temp_df is None or len(temp_df) == 0:
    print("[DEBUG] No valid temperature data found in temperature.csv")
    sys.exit(1)

# Extract steps and temperatures
steps = temp_df['Step'].astype(int).values
temps = temp_df['Temperature'].astype(float).values

print(f"[DEBUG] Temperature data: {len(steps)} timesteps")
print(f"[DEBUG] Step range: {steps.min()} to {steps.max()}")
print(f"[DEBUG] Temperature range: {temps.min():.2f} to {temps.max():.2f}")

total_sim_time = int(steps.max())
print("Total simulation time:", total_sim_time)

# Calculate the exact timestep when cnt_bot setforce becomes 0.0 0.0 0.0
# Based on unbreakable.lmp: 100 (initial) + LEFT_FORCE_DURATION (main) + 100 (0.1 force) + 100 (0.01 force)
force_zero_timestep = 100 + args.left_force_duration + 100 + 100

# Define the timesteps where velocity is nonzero for each end
# Both arrows should disappear when force becomes zero
arrow_top_on_until = force_zero_timestep
arrow_bot_on_until = force_zero_timestep

for i, ts in enumerate(u.trajectory):
    if i % 20 != 0:  # Skip more frames for 4x speedup
        continue

    positions = u.atoms.positions
    cnt_top = u.atoms[:N]
    cnt_bot = u.atoms[-N:]

    # --- Create figure with two rows: main + life plot ---
    fig = plt.figure(figsize=(8, 6))  # Wider figure to accommodate arrows and plot
    gs = gridspec.GridSpec(2, 1, height_ratios=[3, 1], hspace=0.3)  # Add space between plots
    ax_main = fig.add_subplot(gs[0])
    ax_life = fig.add_subplot(gs[1])

    # --- Main plot (as before) ---
    mean_y = np.mean(u.atoms.positions[:, 1])
    for bond in u.bonds:
        pos1, pos2 = bond.atoms.positions
        y_avg = np.mean([pos1[1], pos2[1]])
        alpha = np.exp(-np.abs(y_avg - mean_y)/decay)
        ax_main.plot([pos1[0], pos2[0]], [pos1[1], pos2[1]], color='hotpink', linewidth=2, alpha=alpha)
    center_y = np.mean(positions[:, 1])
    left_x = np.mean(cnt_top.positions[:, 0])
    right_x = np.mean(cnt_bot.positions[:, 0])

    # --- Fix: define current_step before using it ---
    current_step = int(ts.time)

    # Draw left arrow if current_step < force_zero_timestep (when setforce 0.0 0.0 0.0 is applied to cnt_top)
    if current_step < force_zero_timestep:
        ax_main.arrow(left_x, center_y, -arrow_length/3, 0, width=arrow_width, color='blue', head_width=arrow_head, head_length=arrow_head)
    # Draw right arrow always (cnt_bot continues to have forces applied throughout simulation)
    ax_main.arrow(right_x, center_y, arrow_length/3, 0, width=arrow_width, color='blue', head_width=arrow_head, head_length=arrow_head)
    ax_main.set_title(f"Timestep {ts.time:.0f}", fontsize=18)
    ax_main.axis('off')
    # Extend xlim to accommodate arrows and ensure they're visible
    arrow_padding = max(arrow_length/2, 50)  # Ensure enough space for arrows
    ax_main.set_xlim(xlim[0] - arrow_padding, xlim[1] + arrow_padding)
    ax_main.set_ylim(ylim)

    # --- Life plot (temperature vs time) ---
    # Find the closest step index for the current frame
    current_step = int(ts.time)
    idx = (steps <= current_step)
    ax_life.set_xlim(0, total_sim_time)
    ax_life.plot(steps, temps, color='gray', alpha=0.3)
    ax_life.plot(steps[idx], temps[idx], color='red', linewidth=2)
    ax_life.set_ylabel('Temp')
    ax_life.set_xlabel('Step')
    ax_life.set_ylim(temps.min(), temps.max())
    ax_life.grid(True, alpha=0.2)

    plt.tight_layout(pad=0.5)  # Add small padding to prevent cutoff
    fig.canvas.draw()
    image = np.frombuffer(fig.canvas.buffer_rgba(), dtype='uint8').reshape(fig.canvas.get_width_height()[::-1] + (4,))
    images.append(image[..., :3])
    plt.close(fig)

if images:
    fps = 300  # Set your desired frames per second
    duration = 1 / fps
    imageio.mimsave('trajectory_with_arrows.gif', images, duration=duration, loop=0)
else:
    print("No images generated.")

    # --- Add quiver plot for velocity vectors ---
    # Extract x, y, z components of velocity for the first N atoms (cnt_top)
    u_vel = u.atoms[:N].velocities[:, 0]
    v_vel = u.atoms[:N].velocities[:, 1]
    # Scale down for better visibility
    u_vel_scaled = u_vel / 3.0
    v_vel_scaled = v_vel / 3.0
    # Create a grid of arrows
    ax_main.quiver(x, y, u_vel_scaled, v_vel_scaled, angles='xy', scale_units='xy', scale=1, color='green', linewidth=1.5)

    # --- Optional: Add a colorbar for temperature ---
    norm = plt.Normalize(temps.min(), temps.max())
    sm = plt.cm.ScalarMappable(cmap="hot", norm=norm)
    sm.set_array([])
    cbar = plt.colorbar(sm, ax=ax_life, orientation="vertical", pad=0.1)
    cbar.set_label("Temperature (K)")

total_sim_time = int(steps.max())
print("Total simulation time:", total_sim_time)

# The temperature data is now read from CSV above, so we can remove the old parsing functions
